package GraphicElements;

import javafx.animation.AnimationTimer;
import javafx.beans.binding.Bindings;
import javafx.beans.binding.IntegerBinding;
import javafx.geometry.Point2D;
import javafx.scene.image.ImageView;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;

import java.util.ArrayList;

/*
 * Carlos Andrés Reyes Evangelista
 * Universidad de las Américas Puebla
 * Ingeniería en Sistemas Computacionales
 *
 * May 9, 2019
 */

/**
 * Object that defines a graphical node (circle) and the animation and conditions required for create the illusion of
 * constant movement and predictable bouncing in collision with other objects
 * This object represents graphically an Individual for this project
 *
 * IMPORTANT: A Bouncer IS NOT an Individual, but the graphical representation created with the parameters of one
 * These two concepts are related in the following way:
 * 1. An Individual is generated by setting the values of the attributes defined in the Individual class
 * 2. Those values are used to create an instance of this class
 * 3. This Bouncer will participate in a simulation and based on its performance it will
 *    receive a fitness value
 * 4. Once the Bouncer receive its fitness value it will set that value to the Individual from which it was created
 */
public class Bouncer {
	/*
	FLAGS USED FOR INDICATE AND IDENTIFY COLLISIONS
	 */
	private final int NOTHING_TOUCHED           = 0;
	private final int NORTHERN_WALL             = 1;
	private final int SOUTHERN_WALL             = 2;
	private final int WESTERN_WALL              = 3;
	private final int EASTERN_WALL              = 4;
	private final int NORTHWEST_WALL            = 5;
	private final int NORTHEAST_WALL            = 6;
	private final int SOUTHWEST_WALL            = 7;
	private final int SOUTHEAST_WALL            = 8;
	private final int OBSTACLE_HIT_FROM_BASE    = 9;
	private final int OBSTACLE_HIT_FROM_SIDE    = 10;
	private final int OBSTACLE_HIT_FROM_CORNER  = 11;
	private final int TARGET_HIT                = 12;
	
	/**
	 * The maze that contains the objects this bouncer can collide and bounce to
	 */
	private Maze bouncingArea;
	
	/**
	 * The graphical representation of this bouncer is made mean a circle
	 */
	private Circle node;
	
	/*
	Properties that represent current attributes of the bouncer, used for the animation
	 */
	private double currentDirection;
	private double stepX, stepY;
	private double velocity;
	private long initialDelay;
	
	/**
	 * Variable that changes every time the centerX or centerY of node is changed.
	 * Used to perform the required conditions to check if a collision have occurred
	 */
	private IntegerBinding collide;
	
	/**
	 * The inner animation of this bouncer is represented by an AnimationTimer
	 */
	private AnimationTimer bouncingAnimation;
	
	/*
	Maximum and minimum distance the bouncer can possibly be located in relation to the target zone
	 */
	private double maximumDistance;
	private double minimumDistance;
	
	/*
	Properties to perform the required calculations in order to the quantize the performance of this bouncer
	 */
	private Point2D targetPoint;
	private double closestX;
	private double closestY;
	private double closestDistance;
	private double fitnessValue;
	
	/**
	 * Create a new bouncer with the given data
	 * @param position point indicating the initial X and Y points where the center of the circle will be located
	 *                 Relative to the bouncingArea
	 * @param radius radius of the node of this bouncer
	 * @param maze a reference to an object Maze, must contain the proper references to the bouncingArea and obstacles objects
	 * @param currentDirection the initial direction in radians this bouncer must begin
	 * @param velocity the amount of pixels this bouncer should move every time it moves
	 * @param initialDelay the amount in seconds this bouncer will wait until it begins its simulation
	 */
	public Bouncer (Point2D position, double radius, Maze maze, double currentDirection, double velocity, long initialDelay) {
		ArrayList <Rectangle> obstacles = maze.getObstacleNodes();
		ImageView targetZone = maze.getTargetZone();
		
		this.node = new Circle(position.getX(), position.getY(), radius, Color.AQUA);
		this.node.setStroke(Color.BLACK);
		
		this.currentDirection = currentDirection;
		this.velocity = velocity;
		this.stepX = velocity * Math.cos(currentDirection);
		this.stepY = -velocity * Math.sin(currentDirection);
		this.initialDelay = initialDelay;
		
		this.bouncingArea = maze;
		this.fitnessValue = 0;
		this.targetPoint = new Point2D(targetZone.getX() + targetZone.getFitWidth() / 2, targetZone.getY() + targetZone.getFitHeight() / 2);
		this.maximumDistance = position.distance(targetPoint);
		this.minimumDistance =  radius + new Point2D(targetZone.getX(), targetZone.getY()).distance(targetPoint);
		this.closestDistance = maximumDistance;
		
		/*
		Initialization of the IntegerBinding collide
		The lambda function within createIntegerBinding will be invoked every time a dependence changes (in this case the
		centerX and centerY properties of node
		Once that center has move this function will be automatically called and it will perform the proper
		calculations to determine whether or not it has collide with the walls or an obstacle, in such case, one of the
		semantic flags will be returned
		 */
		collide = Bindings.createIntegerBinding(
				() -> {
					if (node.getCenterY() - radius <= 0) { //bouncer touched northern wall
						if (node.getCenterX() - radius <= 0) //bouncer also touched western wall
							return NORTHWEST_WALL;
						if (node.getCenterX() + radius >= 500) //bouncer also touched eastern wall
							return NORTHEAST_WALL;
						return NORTHERN_WALL;
					}
					else if (node.getCenterY() + radius >= 500) { //bouncer touched southern wall
						if (node.getCenterX() - radius <= 0) //bouncer also touched western wall
							return SOUTHWEST_WALL;
						if (node.getCenterX() + radius >= 500) //bouncer also touched eastern wall
							return SOUTHEAST_WALL;
						return SOUTHERN_WALL;
					}
					else if (node.getCenterX() - radius <= 0) //bouncer touched western wall
						return WESTERN_WALL;
					else if (node.getCenterX() + radius >= 500)	//bouncer touched eastern wall
						return EASTERN_WALL;
					
					for (Rectangle obstacle : obstacles){
						if (node.intersects(obstacle.localToParent(obstacle.getBoundsInLocal()))) {
							if (node.getCenterX() >= obstacle.getX() + obstacle.getTranslateX() && node.getCenterX() <= obstacle.getY() + obstacle.getTranslateX() + obstacle.getWidth()) {
								return OBSTACLE_HIT_FROM_BASE;
							}
							else if (node.getCenterY() >= obstacle.getY() + obstacle.getTranslateY() && node.getCenterY() <= obstacle.getY() + obstacle.getTranslateY() + obstacle.getHeight())
								return OBSTACLE_HIT_FROM_SIDE;
							else
								return OBSTACLE_HIT_FROM_CORNER;
						}
					}
					
					if (node.intersects(maze.getTargetZone().getBoundsInLocal()))
						return TARGET_HIT;
					
					return NOTHING_TOUCHED;
				},
				node.centerXProperty(),
				node.centerYProperty()
		);
		
		/*
		When collide changes (that will happen in any collision) this Lambda function will be called
		The objective of this function is evaluate the kind of object the bouncer collide with and
		change its direction depending on that evaluation
		 */
		collide.addListener(
				(observable, oldValue, newValue) -> {
					if (newValue.equals(NORTHERN_WALL) || newValue.equals(SOUTHERN_WALL) || newValue.equals(OBSTACLE_HIT_FROM_BASE))
						updateDirection(2 * Math.PI - this.currentDirection);
					else if (newValue.equals(WESTERN_WALL) || newValue.equals(EASTERN_WALL) || newValue.equals(OBSTACLE_HIT_FROM_SIDE))
						updateDirection(Math.PI - this.currentDirection);
					else if (newValue.equals(NORTHWEST_WALL)
							         || newValue.equals(NORTHEAST_WALL)
							         || newValue.equals(SOUTHWEST_WALL)
							         || newValue.equals(SOUTHEAST_WALL))
						updateDirection(this.currentDirection + Math.PI);
					else if (newValue.equals(OBSTACLE_HIT_FROM_CORNER))
						updateDirection(Math.PI - this.currentDirection);
					else if (newValue.equals(TARGET_HIT)) {
//						this.fitnessValue = 1;
						stop();
					}
				}
		);
		
		/*
		The animation of this bouncer is initialized here
		The method handle of the new AnimationTimer created will be invoked every time the scene is rendered and
		send a timestamp with the tag "now", this represents an amount in nanoseconds.
		This override function will move the bouncer every 1000 nanoseconds and will check if it is closer to the target
		zone than any before
		 */
		bouncingAnimation = new AnimationTimer() {
			private long lastUpdate = 0;
			@Override
			public void handle(long now) {
				if (now - lastUpdate >= 1000) {
					move();
					computeClosestDistance();
					lastUpdate = now;
				}
			}
		};
	}
	
	/*
	GETTERS
	 */
	public Circle getNode() {
		return node;
	}
	
	public long getInitialDelay() {
		return initialDelay;
	}
	
	/**
	 * To compute if the bouncer is in its closest position yet it compares the current distance to the center of the
	 * target zone against its previous closest distance, if it is smaller then updates that attribute and
	 * recalculate the fitness value of this bouncer
	 */
	private void computeClosestDistance() {
		double currentDistance = new Point2D(node.getCenterX(), node.getCenterY()).distance(targetPoint);
		
		if (currentDistance < closestDistance) {
			this.closestDistance = currentDistance;
			this.closestX = node.getCenterX();
			this.closestY = node.getCenterY();
			
			calculateFitnessValue();
			
		}
		
		this.closestDistance = currentDistance < closestDistance ? currentDistance : closestDistance;
	}
	
	/**
	 * In order to assign a fitness value to a bouncer two conditions are checked:
	 * 1. Its distance to the target zone
	 * 2. The amount of obstacles that are in between the node and the target zone
	 *
	 * The closest the distance to the target zone, the higher the fitness value,
	 * but it lose some points if it still had to pass some obstacle when its closest distance was calculated
	 */
	private void calculateFitnessValue() {
		fitnessValue = (minimumDistance - closestDistance) / (maximumDistance - minimumDistance) + 1;
		
		Line line = new Line(closestX, closestY, targetPoint.getX(), targetPoint.getY());
		for (Rectangle obstacle : bouncingArea.getObstacleNodes()) {
			if (line.intersects(obstacle.localToParent(obstacle.getBoundsInLocal())))
				fitnessValue -= 0.05;
		}
		
	}
	
	/**
	 * The fitness value obtained by the previous function may exceed 1 or be less than 0, for some cents
	 * This function normalizes that value and return it
	 * @return a number between 0 and 1 representing to the performance of this bouncer
	 */
	public double getFitnessValue() {
		return fitnessValue > 1 ? 1 : (fitnessValue < 0) ? 0 : fitnessValue;
	}
	
	/*
	ANIMATION METHODS
	 */
	
	/**
	 * Whenever this node is asked to move it changes its center by the amounts indicated by stepX and stepY
	 */
	private void move () {
		node.setCenterX(node.getCenterX() + stepX);
		node.setCenterY(node.getCenterY() + stepY);
	}
	
	public void play () {
		bouncingAnimation.start();
	}
	
	public void stop () {
		bouncingAnimation.stop();
	}
	
	/**
	 * When a collide is detected the current course is updated according to the angle received.
	 * The stepX and stepY units are updated too. They represent the velocity (pixels per frame) the bouncer must
	 * move and the direction. May be negative.
	 *
	 * The stepY particularly have to be negated because the Y-axis is upside-down
	 * @param newDirection a new direction in radians
	 */
	private void updateDirection (double newDirection) {
		this.currentDirection = newDirection;
		this.stepX = velocity * Math.cos(currentDirection);
		this.stepY = -velocity * Math.sin(currentDirection);
	}
}
