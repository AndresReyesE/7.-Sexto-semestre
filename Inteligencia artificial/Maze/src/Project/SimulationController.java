package Project;

import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ProgressBar;
import javafx.scene.layout.AnchorPane;

import java.net.URL;
import java.util.*;

/*
 * Carlos Andrés Reyes Evangelista
 * Universidad de las Américas Puebla
 * Ingeniería en Sistemas Computacionales
 *
 * May 9, 2019
 */

/**
 * Controller for the Simulation View, handles the events generated by the user
 */
public class SimulationController implements Initializable {
	
	private Model model;
	private long simulationTime;
	
	@FXML
	private AnchorPane pane;
	@FXML
	private Label labelCurrentGeneration, labelCurrentFittest;
	@FXML
	private Button buttonStartSimulation, buttonRepeat;
	@FXML
	private ProgressBar progressBar;
	
	/**
	 * Add any node to the pane of this view
	 * @param node any object which extends from Node
	 */
	void addNode (Node node) {
		pane.getChildren().add(node);
	}
	
	/**
	 * Add all the elements of a collection to this view
	 * @param nodes a collection which elements extend from Node
	 */
	void addNodes (Collection <? extends Node> nodes) {
		pane.getChildren().addAll(nodes);
	}
	
	/**
	 * Remove a node from this view
	 * @param node any object which extends from Node
	 */
	void removeNode (Node node) {
		pane.getChildren().remove(node);
	}
	
	/**
	 * Sets the reference to the model used in this session
	 * @param model a not null instance of Model
	 */
	void setModel(Model model) {
		this.model = model;
	}
	
	/**
	 * User-chosen time limit that all the bouncers have for reach the target zone
	 * @param simulationTime an arbitrary amount of time given in milliseconds
	 */
	void setSimulationTime(long simulationTime) {
		this.simulationTime = simulationTime;
	}
	
	/*
		EVENT HANDLERS
	*/
	
	/**
	 * When the "Start simulation" button is clicked ask the model to compute the next generation (if any)
	 */
	@FXML
	public void startSimulation() {
		model.nextGeneration();
	}
	
	/**
	 * When the "Repeat simulation" button is clicked, it is not computed a new generation, but used the one existent to
	 * regenerate the bouncers and play the animations one more time. It doesn't update anything in the GA.
	 * Some visual variations may occur due to nanoseconds conditionals difference occasioned by minor changes in the
	 * CPU's clock (known bug)
	 */
	@FXML
	public void repeatSimulation() {
		model.createBouncers();
		model.initiateSimulation();
		inSimulation();
	}
	
	/**
	 * Whenever any simulation is running, the buttons must be disabled to not occasioned collisions in overlapped
	 * simulations
	 * Additionally a progress bar is initiated to show the user the progress of the simulation (it begins and ends
	 * at the same time than the simulation). Useful for long simulations, to confirm that everything's running alright
	 */
	void inSimulation() {
		Timer timer = new Timer();

		buttonStartSimulation.setDisable(true);
		buttonRepeat.setDisable(true);
		
		timer.scheduleAtFixedRate(new TimerTask() {
			double progress = 0;
			@Override
			public void run() {
				progress += 0.01;
				progressBar.setProgress(progress);
				
			}
		}, 0, simulationTime/100);
		
		
		timer.schedule(new TimerTask() {
			@Override
			public void run() {
				buttonStartSimulation.setDisable(false);
				buttonRepeat.setDisable(false);
				timer.cancel();
			}
		}, simulationTime + 100);
	}
	
	/**
	 * Package-private method to allow foreign classes to update the number of generations elapsed
	 * Update the corresponding label in this view
	 * @param currentGeneration
	 */
	void updateCurrentGeneration(String currentGeneration) {
		if (currentGeneration.equals("You've reached the limit of generations"))
			buttonStartSimulation.setVisible(false);
		else {
			labelCurrentGeneration.setText(currentGeneration);
			buttonStartSimulation.setText("Simulate next generation");
			buttonRepeat.setVisible(true);
		}
	}
	
	/**
	 * Package-private method to allow foreign classes to update the fittest value obtained in the simulation
	 * Update the corresponding label in this view
	 * @param fittestValue
	 */
	void updateFittest(double fittestValue) {
		labelCurrentFittest.setText(String.format("%.2f", fittestValue));
	}
	
	
	@Override
	public void initialize(URL location, ResourceBundle resources) {
		buttonRepeat.setVisible(false);
	}
}
